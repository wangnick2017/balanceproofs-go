package fft

import "github.com/alinush/go-mcl"

var Scale2RootOfUnity []mcl.Fr

func ToFr(v string) (out mcl.Fr) {
    out.SetString(v, 10)
    return
}

func InitGlobals() {

    // MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513
    // PRIMITIVE_ROOT = 7
    // [pow(PRIMITIVE_ROOT, (MODULUS - 1) // (2**i), MODULUS) for i in range(32)]
    Scale2RootOfUnity = []mcl.Fr{
        /* k=0          r=1          */ ToFr("1"),
        /* k=1          r=2          */ ToFr("52435875175126190479447740508185965837690552500527637822603658699938581184512"),
        /* k=2          r=4          */ ToFr("3465144826073652318776269530687742778270252468765361963008"),
        /* k=3          r=8          */ ToFr("23674694431658770659612952115660802947967373701506253797663184111817857449850"),
        /* k=4          r=16         */ ToFr("14788168760825820622209131888203028446852016562542525606630160374691593895118"),
        /* k=5          r=32         */ ToFr("36581797046584068049060372878520385032448812009597153775348195406694427778894"),
        /* k=6          r=64         */ ToFr("31519469946562159605140591558550197856588417350474800936898404023113662197331"),
        /* k=7          r=128        */ ToFr("47309214877430199588914062438791732591241783999377560080318349803002842391998"),
        /* k=8          r=256        */ ToFr("36007022166693598376559747923784822035233416720563672082740011604939309541707"),
        /* k=9          r=512        */ ToFr("4214636447306890335450803789410475782380792963881561516561680164772024173390"),
        /* k=10         r=1024       */ ToFr("22781213702924172180523978385542388841346373992886390990881355510284839737428"),
        /* k=11         r=2048       */ ToFr("49307615728544765012166121802278658070711169839041683575071795236746050763237"),
        /* k=12         r=4096       */ ToFr("39033254847818212395286706435128746857159659164139250548781411570340225835782"),
        /* k=13         r=8192       */ ToFr("32731401973776920074999878620293785439674386180695720638377027142500196583783"),
        /* k=14         r=16384      */ ToFr("39072540533732477250409069030641316533649120504872707460480262653418090977761"),
        /* k=15         r=32768      */ ToFr("22872204467218851938836547481240843888453165451755431061227190987689039608686"),
        /* k=16         r=65536      */ ToFr("15076889834420168339092859836519192632846122361203618639585008852351569017005"),
        /* k=17         r=131072     */ ToFr("15495926509001846844474268026226183818445427694968626800913907911890390421264"),
        /* k=18         r=262144     */ ToFr("20439484849038267462774237595151440867617792718791690563928621375157525968123"),
        /* k=19         r=524288     */ ToFr("37115000097562964541269718788523040559386243094666416358585267518228781043101"),
        /* k=20         r=1048576    */ ToFr("1755840822790712607783180844474754741366353396308200820563736496551326485835"),
        /* k=21         r=2097152    */ ToFr("32468834368094611004052562760214251466632493208153926274007662173556188291130"),
        /* k=22         r=4194304    */ ToFr("4859563557044021881916617240989566298388494151979623102977292742331120628579"),
        /* k=23         r=8388608    */ ToFr("52167942466760591552294394977846462646742207006759917080697723404762651336366"),
        /* k=24         r=16777216   */ ToFr("18596002123094854211120822350746157678791770803088570110573239418060655130524"),
        /* k=25         r=33554432   */ ToFr("734830308204920577628633053915970695663549910788964686411700880930222744862"),
        /* k=26         r=67108864   */ ToFr("4541622677469846713471916119560591929733417256448031920623614406126544048514"),
        /* k=27         r=134217728  */ ToFr("15932505959375582308231798849995567447410469395474322018100309999481287547373"),
        /* k=28         r=268435456  */ ToFr("37480612446576615530266821837655054090426372233228960378061628060638903214217"),
        /* k=29         r=536870912  */ ToFr("5660829372603820951332104046316074966592589311213397907344198301300676239643"),
        /* k=30         r=1073741824 */ ToFr("20094891866007995289136270587723853997043774683345353712639419774914899074390"),
        /* k=31         r=2147483648 */ ToFr("34070893824967080313820779135880760772780807222436853681508667398599787661631"),
    }
}

const (
    mask0 = ^uint32((1 << (1 << iota)) - 1)
    mask1
    mask2
    mask3
    mask4
    //mask5
)

const (
    bit0 = uint8(1 << iota)
    bit1
    bit2
    bit3
    bit4
    //bit5
)

// bitmagic: binary search through a uint32 to find the index (least bit being 0) of the first set bit.
// Zero is a special case, it has a 0 bit index.
// Example:
//  (in out): (0 0), (1 0), (2 1), (3 1), (4 2), (5 2), (6 2), (7 2), (8 3), (9 3)
func bitIndex(v uint32) (out uint8) {
    if v == 0 {
        return 0
    }
    //if v&mask5 != 0 {
    //	v >>= bit5
    //	out |= bit5
    //}
    if v&mask4 != 0 {
        v >>= bit4
        out |= bit4
    }
    if v&mask3 != 0 {
        v >>= bit3
        out |= bit3
    }
    if v&mask2 != 0 {
        v >>= bit2
        out |= bit2
    }
    if v&mask1 != 0 {
        v >>= bit1
        out |= bit1
    }
    if v&mask0 != 0 {
        out |= bit0
    }
    return
}

var revByte = [256]byte{
    0b00000000, 0b10000000, 0b01000000, 0b11000000, 0b00100000, 0b10100000, 0b01100000, 0b11100000, 0b00010000, 0b10010000, 0b01010000, 0b11010000, 0b00110000, 0b10110000, 0b01110000, 0b11110000,
    0b00001000, 0b10001000, 0b01001000, 0b11001000, 0b00101000, 0b10101000, 0b01101000, 0b11101000, 0b00011000, 0b10011000, 0b01011000, 0b11011000, 0b00111000, 0b10111000, 0b01111000, 0b11111000,
    0b00000100, 0b10000100, 0b01000100, 0b11000100, 0b00100100, 0b10100100, 0b01100100, 0b11100100, 0b00010100, 0b10010100, 0b01010100, 0b11010100, 0b00110100, 0b10110100, 0b01110100, 0b11110100,
    0b00001100, 0b10001100, 0b01001100, 0b11001100, 0b00101100, 0b10101100, 0b01101100, 0b11101100, 0b00011100, 0b10011100, 0b01011100, 0b11011100, 0b00111100, 0b10111100, 0b01111100, 0b11111100,
    0b00000010, 0b10000010, 0b01000010, 0b11000010, 0b00100010, 0b10100010, 0b01100010, 0b11100010, 0b00010010, 0b10010010, 0b01010010, 0b11010010, 0b00110010, 0b10110010, 0b01110010, 0b11110010,
    0b00001010, 0b10001010, 0b01001010, 0b11001010, 0b00101010, 0b10101010, 0b01101010, 0b11101010, 0b00011010, 0b10011010, 0b01011010, 0b11011010, 0b00111010, 0b10111010, 0b01111010, 0b11111010,
    0b00000110, 0b10000110, 0b01000110, 0b11000110, 0b00100110, 0b10100110, 0b01100110, 0b11100110, 0b00010110, 0b10010110, 0b01010110, 0b11010110, 0b00110110, 0b10110110, 0b01110110, 0b11110110,
    0b00001110, 0b10001110, 0b01001110, 0b11001110, 0b00101110, 0b10101110, 0b01101110, 0b11101110, 0b00011110, 0b10011110, 0b01011110, 0b11011110, 0b00111110, 0b10111110, 0b01111110, 0b11111110,
    0b00000001, 0b10000001, 0b01000001, 0b11000001, 0b00100001, 0b10100001, 0b01100001, 0b11100001, 0b00010001, 0b10010001, 0b01010001, 0b11010001, 0b00110001, 0b10110001, 0b01110001, 0b11110001,
    0b00001001, 0b10001001, 0b01001001, 0b11001001, 0b00101001, 0b10101001, 0b01101001, 0b11101001, 0b00011001, 0b10011001, 0b01011001, 0b11011001, 0b00111001, 0b10111001, 0b01111001, 0b11111001,
    0b00000101, 0b10000101, 0b01000101, 0b11000101, 0b00100101, 0b10100101, 0b01100101, 0b11100101, 0b00010101, 0b10010101, 0b01010101, 0b11010101, 0b00110101, 0b10110101, 0b01110101, 0b11110101,
    0b00001101, 0b10001101, 0b01001101, 0b11001101, 0b00101101, 0b10101101, 0b01101101, 0b11101101, 0b00011101, 0b10011101, 0b01011101, 0b11011101, 0b00111101, 0b10111101, 0b01111101, 0b11111101,
    0b00000011, 0b10000011, 0b01000011, 0b11000011, 0b00100011, 0b10100011, 0b01100011, 0b11100011, 0b00010011, 0b10010011, 0b01010011, 0b11010011, 0b00110011, 0b10110011, 0b01110011, 0b11110011,
    0b00001011, 0b10001011, 0b01001011, 0b11001011, 0b00101011, 0b10101011, 0b01101011, 0b11101011, 0b00011011, 0b10011011, 0b01011011, 0b11011011, 0b00111011, 0b10111011, 0b01111011, 0b11111011,
    0b00000111, 0b10000111, 0b01000111, 0b11000111, 0b00100111, 0b10100111, 0b01100111, 0b11100111, 0b00010111, 0b10010111, 0b01010111, 0b11010111, 0b00110111, 0b10110111, 0b01110111, 0b11110111,
    0b00001111, 0b10001111, 0b01001111, 0b11001111, 0b00101111, 0b10101111, 0b01101111, 0b11101111, 0b00011111, 0b10011111, 0b01011111, 0b11011111, 0b00111111, 0b10111111, 0b01111111, 0b11111111,
}

func reverseBits(b uint32) uint32 {
    return (uint32(revByte[uint8(b)]) << 24) |
        (uint32(revByte[uint8(b>>8)]) << 16) |
        (uint32(revByte[uint8(b>>16)]) << 8) |
        uint32(revByte[uint8(b>>24)])
}

func reverseBitsLimited(length uint32, value uint32) uint32 {
    return reverseBits(value) >> (32 - bitIndex(length))
}

func reverseBitOrder(length uint32, swap func(i, j uint32)) {
    if !(length > 0 || (length&(length-1) == 0)) {
        panic("length is not a power of 2")
    }
    // swap bits:
    // 00000000000000000000000000000001 -> 10000000000000000000000000000000
    // then adjust, e.g. we may only want to swap the first 4 bits:
    // 10000000000000000000000000000000 >> (32 - 4) = 1000
    unusedBitLen := 32 - bitIndex(length)
    for i := uint32(0); i < length; i++ {
        // only swap every pair once. If pair items are equal, nothing to do, skip work.
        if r := reverseBits(i) >> unusedBitLen; r > i {
            swap(r, i)
        }
    }
}
